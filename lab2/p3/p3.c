/*
 * 3. Написать программу, в которой процесс порождает новый и позволяет порожденному процессу завершиться. 
 * Оба процесса должны выводить свои идентификаторы (процесса, родительского процесса, группы процессов). 
 * Проверить идентификатор и статус завершения порожденного процесса. Выполнить данную программу и посмотреть ее результаты.
*/
#include <stdlib.h>
#include <stdio.h>
#include <sys/types.h>
#include <unistd.h>
#include <sys/wait.h>

int main(int argc, char * argv[]){
    int pid;
    if((pid = fork()) == -1){
		/*
		 * fork возвращает id дочернего процесса, которому он стал родителем
		 * pid дочернего устанавливается в 0
		 * pid родительского принимает новое значение
		*/
        perror("[P] fork error");
        exit(0);
    }

    if(pid>0){ //родитель
        printf("[P] Это сообщение выведено из родительского процесса\n");
        printf("[P] fork returned (дочерний) = %d\n", pid); //уникальный идентификатор 
        printf("[P] Process group = %d\n",getpgrp()); 
        /*
         * Процесс имеет возможность определить идентификатор собственной группы процес-
		   сов или группы процесса, который является членом того же сеанса. Для этого
           используются два системных вызова: getpgrp(2) и getpgid(2) :
        */
        printf("[P] PID = %d\n", getpid());
        printf("[P] PPID = %d\n",getppid());
        printf("[P] Ожидаем завершения дочернего процесса\n");
        int code; //объявляем переменную статуса завершения
        if(wait(&code) == -1) { //ошибка 
            perror("[P] wait error");
        }
        else{
            printf("[P] Дочерний процесс завершён! Статус завершения: %d\n",WEXITSTATUS(code));
        }
		return 0;
    }
    else{ //дочерний
        printf("[C] Это сообщение выведено из дочернего процесса\n");
        printf("[C] fork returned = %d\n", pid);
        printf("[C] Process group = %d\n", getpgrp());
        printf("[C] PID = %d\n", getpid());
        printf("[C] PPID = %d\n", getppid());
        return 2;
    }
}








/*
 * fork выделяет новый pid для процесса но оставляет старыми значения стека, сегмента кода, данных...
 * ./n3 prog
*/
